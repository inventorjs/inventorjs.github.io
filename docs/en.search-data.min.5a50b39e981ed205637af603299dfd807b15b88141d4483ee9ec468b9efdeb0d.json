[{"id":0,"href":"/docs/cli/","title":"cli","section":"Docs","content":" @inventorjs/cli # 前端脚手架框架，采用插件架构设计，内置脚手架核心及其他常用插件，实现开箱即用，开发者可使用框架提供的脚手架插件快速开发插件。\n脚手架框架解决的问题 # 1、命令管理：开发者无需关心底层 commander 等各种复杂工具的使用，只需要按规范实现对象功能即可 2、环境管理：脚手架运行环境往往比较负责，编写脚手架不在需要关心运行环境，有框架内不管理 3、文件管理：开发者无需关心底层文件读写，通过调用上层接口如果\u0026quot;渲染模版\u0026quot;，即可实现快速生成功能 4、cmd管理：开发者无需关心底层 execa 底层工具的复杂调用，封装上层功能，仅通过传异步任务即可实现命令调用，并封装输入输出，自动格式化 5、配置管理：脚手架往往需要一个配置文件，而开发这难于管理，框架提供上层抽象能力，方便管理 6、日志管理：框架提供完备的日志打印封装，提供多种日志打印场景，开发这不需要关心底层细节即可实现标准输出 7、插件管理：框架采用插件化设计(类似 yoman)，开发者可通过统一入口管理插件，无需更多脚手架命令，可实现自动化插件管理 8、快速开发：框架提供快速开发模版，一分钟内即可完成一个脚手架插件初始化并发布，开发者只需要实现插件功能即可\n前置说明 # corepack 作为 node 新版本的包管理工具，用于管理(yarn, pnpm)包工具，强烈建议开启 corepack corepack enable 脚手架强制使用 pnpm(当前最先进的包管理工具) 作为包管理工具, 使用前请确保已全局安装 pnpm 安装 # 由于脚手架采用插件话设计(参考 @babel/cli)，所以将脚手架核心功能抽离至 @inventorjs/core 中，各个插件采用 peerDependencies 的方式引用，来确保 @inventorjs/core 版本的一致性\n// 安装脚手架以及脚手架核心 pnpm add @inventorjs/cli-core @inventorjs/cli-core -g 使用 # 使用内置插件 # 当前插件内置插件列表，后续可能会新增更多内置插件\ninventor-plugin-plugin: 用于快速开发 inventor 插件 inventor-plugin-app: 用于快速开发前端应用，支持多种前端应用模版 // 查看可用的插件命令 inventor -h // 查看 plugin 插件的使用方式 inventor plugin // 查看 app 插件的使用方式 inventor app 安装第三方插件 # 第三方插件强制格式为 (@scope/)inventor-plugin-[name]，由第三方人员开发，可根据功能进行安装 注意：plugin 命令默认会自动注册插件至 .inventorrc，如果配置文件非 json 格式，可能回注册失败，手动注册即可以\n// 自动安装第三方插件，如安装 inventor-plugin-test，默认全局安装，如需要局部安装添加 --local 参数即可安装到当前目录 inventor plugin add inventor-plugin-test // 全局调用使用第三方插件 inventor test // 本地调用第三方插件 pnpm inventor test "},{"id":1,"href":"/docs/cli/cli-core/plugin/","title":"Plugin[插件基础类]","section":"cli-core[脚手架核心]","content":" 插件基础抽象类(Plugin) # 插件实例基础抽象类，封装常用的脚手架插件开发相关功能，插件需要继承该抽象类以实现插件功能(其中 abtract 方法和属性为子插件必须实现的)，插件实例通过脚手架框架内部自动创建，插件开发者无需手动初始化插件实例，插件实例和方法在子插件种皆可通过 this 获取。\nnew Plugin(params) # 插件构造函数为脚手架框架内部调用，插件开发者无需创建插件实例\nparams: entryPath: \u0026lt;string\u0026gt; 插件入口路径 this.entryPath # Type: \u0026lt;string\u0026gt; 插件入口路径 this.templatePath # Type: \u0026lt;string\u0026gt; 插件模版路径 this.actionPath # Type: \u0026lt;string\u0026gt; action 文件夹路径 this.prompt(questions) # 实现命令行可交互问答，对 inquirer 核心功能封装\nquestions: \u0026lt;Object[]\u0026gt; 问题数组 type: \u0026lt;checkbox|text\u0026gt; 问题类型 name: \u0026lt;string\u0026gt; 问题键名 message: \u0026lt;string\u0026gt; 问题描述 choices: \u0026lt;Object[]\u0026gt; 问题可选项 name: \u0026lt;string\u0026gt; 选项名称 value: \u0026lt;string\u0026gt; 选项值 this.install(options) # 在上下文目录执行 pnpm install 进行包安装\noptions: \u0026lt;Object\u0026gt; 调用选项 this.addDependencies(packageNames, options) # 在上下文目录批量添加依赖包\npackageNames: \u0026lt;string[]\u0026gt; 依赖包名称数组(如：axios@1.0.0) this.addDevDependencies(packageNames, options) # 在上下文目录批量添加开发依赖包\npackageNames: \u0026lt;string[]\u0026gt; 依赖包名称数组(如：axios@1.0.0) this.removeDependencies(packageNames, options) # 在上下文目录批量删除依赖包\npackageNames: \u0026lt;string[]\u0026gt; 依赖包名称数组(如：axios@1.0.0) this.removeDevDependencies(packageNames, options) # 在上下文目录批量删除开发依赖包\npackageNames: \u0026lt;string[]\u0026gt; 依赖包名称数组(如：axios@1.0.0) this.getPackageJson(fromPath = this.entryPath) # 从 fromPath 开始查找 package.json 文件直到根目录，并返回 json 对象\nfromPath: \u0026lt;string\u0026gt; 查找起始路径 this.addPackageJsonFields(fieldsData, filePath) # 向 package.json 添加字段\nfieldsData: \u0026lt;Object\u0026gt; 字段数据对象 filePath: \u0026lt;string\u0026gt; package.json 文件路径 this.savePackageJson(filePath, packageJson) # 保存 packageJson 对象到 package.json 文件\nfilePath: \u0026lt;string\u0026gt; package.json 文件路径 packageJson: \u0026lt;Object\u0026gt; packageJson 数据对象 this.getPackageName(fromPath = this.entryPath) # 获取指定路径的 npm 包名称\nfromPath: \u0026lt;string\u0026gt; 查找起始路径 this.getPluginName(frompath = this.entryPath) # 获取指定路径的 inventor-plugin 名称，即命令行执行名称\nfromPath: \u0026lt;string\u0026gt; 查找起始路径 this.confirmOverwrites(paths) # 询问是否覆盖指定路径的文件\npaths: \u0026lt;string[]\u0026gt; 文件路径列表 this.renderTemplate(templateName, destinationName, options) # 渲染指定模版文件夹到目标文件夹\ntemplateName: \u0026lt;string\u0026gt; 模版名称(即在 templates 的子文件夹名称) destinationName: \u0026lt;string\u0026gt; 目标文件夹名称 options: \u0026lt;Object\u0026gt; 模版渲染选项 data: \u0026lt;Object\u0026gt; 模版数据 overwrites: \u0026lt;Boolean\u0026gt; 是否覆盖已存在目标文件 this.renderTemplateFile(templateName, templateFile, destinationFile, options) # 渲染指定模版文件到目标文件\ntemplateName: \u0026lt;string\u0026gt; 模版名称(即在 templates 的子文件夹名称) templateFile: \u0026lt;string\u0026gt; 模版目录下的文件，相对模版路径 destinationFile: \u0026lt;string\u0026gt; 目标文件名称 options: \u0026lt;Object\u0026gt; 模版渲染选项 data: \u0026lt;Object\u0026gt; 模版数据 overwrites: \u0026lt;Boolean\u0026gt; 是否覆盖已存在目标文件 "},{"id":2,"href":"/docs/cli/cli-core/modules/cmd/","title":"cmd[命令处理模块]","section":"modules[模块]","content":" 命令行程序调用模块 # 封装 execa 调用方法，提供对返回数据 buffer 进行处理的能力\nexec(bin, args, options) # 调用命令行程序\nbin: \u0026lt;string\u0026gt; 执行命令行程序 args: \u0026lt;string[]\u0026gt; 命令行程序参数 options: \u0026lt;Object\u0026gt; output: \u0026lt;Boolean\u0026gt; 是否输出运行结果 pipeline: \u0026lt;\u0026lsquo;stdout\u0026rsquo; | \u0026lsquo;stderr\u0026rsquo;\u0026gt; 输出文件描述符 pipe: \u0026lt;Function\u0026gt; buf: \u0026lt;Buffer\u0026gt; 处理命令输出的 buffer "},{"id":3,"href":"/docs/cli/cli-core/modules/env/","title":"env[环境管理模块]","section":"modules[模块]","content":" 环境管理模块 # 主要提供脚手架当前执行环境的一些相关信息，管理脚手架执行上下文\nisTTY() # 判断当前是否是标准终端环境，如在子进程中(pnpm exec -r), 则返回false\npwd() # 获取当前所在路径\nhomedir() # 获取当前用户家目录\ncontext() # 获取安装脚手架上下文(global|local)\nusername() # 获取当前用户名\nuid() # 获取当前用户 uid\ndirname(metaUrl) # 获取文件所在目录(主要用于转换 import.meta.url)\nmetaUrl: \u0026lt;string\u0026gt; 模块的 import.meta.url 值 filename(metaUrl) { # 获取文件绝对路径(主要用于转换 import.meta.url)\nmetaUrl: \u0026lt;string\u0026gt; 模块的 import.meta.url 值 changeCwd(enterCwd) # 改变当前命令执行上下文目录\nenterCwd: \u0026lt;string\u0026gt; 执行上下文目录 "},{"id":4,"href":"/docs/cli/cli-core/modules/fs/","title":"fs[文件处理模块]","section":"modules[模块]","content":" 文件处理模块 # 导出 fs-extra 常用函数，并封装常用的文件操作功能\nfs-extra 导出函数 # readdir readFile writeFile stat getAllFiles(dirPath) # 获取目标路径下所有文件路径(深层次递归获取)\ndirPath: \u0026lt;string\u0026gt; 目标目录路径 getExistsTemplateFiles(templateDir, destinationDir) # 获取已存在目标文件的模版文件列表\ntemplateDir: \u0026lt;string\u0026gt; 模版目录路径 destinationDir: \u0026lt;string\u0026gt; 目标目录路径 exists(filePath) # 判断目标路径是否存在\nfilePath: \u0026lt;string\u0026gt; 目标路径 renderTemplate(templateDir, destinationDir, options) # 将模版文件夹所有文件渲染到目标文件夹\ntemplateDir: \u0026lt;string\u0026gt; 模版文件夹路径 destinationDir: \u0026lt;string\u0026gt; 目标文件夹路径 options: \u0026lt;Object\u0026gt; 模版渲染选项 data: \u0026lt;Object\u0026gt; 模版数据 renderTemplate(templateFile, destinationFile, options) # 渲染单个模版文件到目标路径\ntemplateFile: \u0026lt;string\u0026gt; 模版文件路径 destinationFile: \u0026lt;string\u0026gt; 目标文件路径 options: \u0026lt;Object\u0026gt; 模版渲染选项 data: \u0026lt;Object\u0026gt; 模版数据 "},{"id":5,"href":"/docs/cli/cli-core/modules/git/","title":"git[git命令模块]","section":"modules[模块]","content":" git 命令模块 # 封装 git 相关命令行工具\ninit(options) # 初始化 git 仓库\noptions: \u0026lt;Object\u0026gt; output: \u0026lt;Boolean\u0026gt; 是否输出运行结果 pipeline: \u0026lt;\u0026lsquo;stdout\u0026rsquo; | \u0026lsquo;stderr\u0026rsquo;\u0026gt; 输出文件描述符 pipe: \u0026lt;Function\u0026gt; buf: \u0026lt;Buffer\u0026gt; 处理命令输出的 buffer "},{"id":6,"href":"/docs/cli/inventor-plugin-app/","title":"inventor-plugin-app[应用管理]","section":"cli","content":" 脚手架内置应用管理插件 # 用户快速创建和开发应用，提供多种快速开发模版，提供开发、构建能力\n支持的应用类型(应用模版如无 js 后缀，则默认使用 ts 语言) # library: 库应用 react-vite: react + vite 应用 react-webpack: react + webpack 应用 react-webpack-js: react + webpack + js 应用(不推荐使用) 使用方式 # 初始化应用 # inventor app init 未现有应用添加工具(如 Husky、Eslint、Commitlint) # inventor app addon "},{"id":7,"href":"/docs/cli/inventor-plugin-plugin/","title":"inventor-plugin-plugin[插件管理]","section":"cli","content":" 脚手架内置插件管理插件 # 用于快速开发 inventor 脚手架插件，提供快速开发模版以及开发调试能力\n使用方式 # 插件本地开发 # 下面以开发 \u0026ldquo;inventor-plugin-test\u0026rdquo; 插件为例\n// 初始化插件，按规则输入插件名称，输入插件包名称 inventor-plugin-test inventor plugin init // 进入插件目录，启动开发 cd inventor-plugin-hello // 将插件链接到全局 pnpm link -g // 修改插件配置文件 ~/.inventorrc 在 plugins 字段添加 [\u0026#34;inventor-plugin-test\u0026#34;] // 启动开发服务器 pnpm dev // 此时即可通过 inventor 命令调用插件 inventor -h 插件发布至仓库 # 发布前记得确认 .npmrc 文件中的 registry，当前默认是 https://registry.npmjs.org\n// 生成新的包版本 pnpm version patch // 发布至 npm 仓库 pnpm publish // 此时可全局安装当前插件如 inventor-plugin-test pnpm add inventor-plugin-hello -g // 然后即可正常使用插件 inventor hello "},{"id":8,"href":"/docs/cli/cli-core/modules/log/","title":"log[日志处理模块]","section":"modules[模块]","content":" 日志处理模块 # clear() # 清空终端输出日志信息，仅对标准终端有效\ninfo(msg, options) # 打印 INFO 类型日志信息\nmsg: \u0026lt;unknown\u0026gt; 日志信息 options: \u0026lt;Object\u0026gt; boxen: \u0026lt;BoxenOptions | true\u0026gt; dedent: \u0026lt;boolean\u0026gt; art: \u0026lt;figlet.Options \u0026amp; { color: green | cyan }\u0026gt; success(msg, options) # 打印 SUCCESS 类型日志信息\nmsg: \u0026lt;unknown\u0026gt; 日志信息 options: \u0026lt;Object\u0026gt; boxen: \u0026lt;BoxenOptions | true\u0026gt; dedent: \u0026lt;boolean\u0026gt; art: \u0026lt;figlet.Options \u0026amp; { color: green | cyan }\u0026gt; error(msg, options) # 打印 ERROR 类型日志信息\nmsg: \u0026lt;unknown\u0026gt; 日志信息 options: \u0026lt;Object\u0026gt; boxen: \u0026lt;BoxenOptions | true\u0026gt; dedent: \u0026lt;boolean\u0026gt; art: \u0026lt;figlet.Options \u0026amp; { color: green | cyan }\u0026gt; warn(msg, options) # 打印 warn 类型日志信息\nmsg: \u0026lt;unknown\u0026gt; 日志信息 options: \u0026lt;Object\u0026gt; boxen: \u0026lt;BoxenOptions | true\u0026gt; dedent: \u0026lt;boolean\u0026gt; art: \u0026lt;figlet.Options \u0026amp; { color: green | cyan }\u0026gt; raw(msg, options) # 将日志转化为字符串，并输出原始日志信息\nmsg: \u0026lt;unknown\u0026gt; 日志信息 options: \u0026lt;Object\u0026gt; boxen: \u0026lt;BoxenOptions | true\u0026gt; dedent: \u0026lt;boolean\u0026gt; art: \u0026lt;figlet.Options \u0026amp; { color: green | cyan }\u0026gt; bye(msg, options) # 打印 bye 类型日志信息，并退出当前进程\nmsg: \u0026lt;unknown\u0026gt; 日志信息 options: \u0026lt;Object\u0026gt; boxen: \u0026lt;BoxenOptions | true\u0026gt; dedent: \u0026lt;boolean\u0026gt; art: \u0026lt;figlet.Options \u0026amp; { color: green | cyan }\u0026gt; "},{"id":9,"href":"/docs/cli/cli-core/modules/pm/","title":"pm[包管理模块]","section":"modules[模块]","content":" pnpm 包管理模块 # 封装常用的 pnpm 包操作指令，并自动处理命令输出，可直接在插件中进行调用\ncheckVersion() # 校验脚手架运行环境是否满足需求(如：pnpm: ^7.12.0)\naddPackageJsonFields(fieldsData, filePath) # 向 package.json 中添加字段\nfieldsData: \u0026lt;Object\u0026gt; 字段键值对 filePath: \u0026lt;Object\u0026gt; package.json 文件路径 getPackageJson(packageJsonPath) # 获取 package.json 文件对象数据\npackageJsonPath: \u0026lt;Object\u0026gt; package.json 文件路径 savePackageJson(savePath, packageJson) # 将对象数据保存都 package.json\nsavePath: \u0026lt;Object\u0026gt; package.json 文件路径 fieldsData: \u0026lt;Object\u0026gt; package.json 数据对象 searchPackageJson(fromPath) # 向上层搜索最近的 package.json\nfromPath: \u0026lt;Object\u0026gt; package.json 搜索起始路径 root(options) # 获取 node_modules 的安装路径\noptions: \u0026lt;Object\u0026gt; init(options) # 初始化 package.json 包\noptions: \u0026lt;Object\u0026gt; addDependencies(packageNames, options) # 安装多个包依赖，并将依赖保存至 package.json\npackageNames: \u0026lt;string[]\u0026gt; 包名@版本列表 options: \u0026lt;Object\u0026gt; addDevDependencies(packageNames, options) # 安装多个开发包依赖，并将依赖保存至 package.json\npackageNames: \u0026lt;string[]\u0026gt; 包名@版本列表 options: \u0026lt;Object\u0026gt; removeDependencies(packageNames, options) # 移除多个包依赖，并从 package.json 中移除\npackageNames: \u0026lt;string[]\u0026gt; 包名@版本列表 options: \u0026lt;Object\u0026gt; removeDevDependencies(packageNames, options) # 移除多个开发包依赖，并从 package.json 中移除\npackageNames: \u0026lt;string[]\u0026gt; 包名@版本列表 options: \u0026lt;Object\u0026gt; "},{"id":10,"href":"/docs/cli/cli-core/modules/rc/","title":"rc[配置文件模块]","section":"modules[模块]","content":" rc 配置文件模块 # 管理 rc 规范的配置文件，包括局部配置文件和全局配置文件\nsearch(dirname) # 搜索符合要求的配置文件\ndirname: \u0026lt;string\u0026gt; 搜索路径 load(from) # from: \u0026lt;\u0026lsquo;local\u0026rsquo;|\u0026lsquo;global\u0026rsquo;\u0026gt; 加载配置文件 "},{"id":11,"href":"/docs/cli/cli-core/modules/util/","title":"util[通用工具模块]","section":"modules[模块]","content":" 通用工具模块 # 封装常用的工具函数\ngetPluginName(packageName) # 通过插件 npm 包名称，获取插件命令名称\npackageName: \u0026lt;string\u0026gt; npm 包名称 humanSize(bytes, options) # 将字节单位转换成人类可读的单位\nbytes: \u0026lt;number\u0026gt; 字节大小 options: \u0026lt;Object\u0026gt; base: \u0026lt;number\u0026gt; 基数 standard: \u0026lt;string\u0026gt; 转换标准 "}]